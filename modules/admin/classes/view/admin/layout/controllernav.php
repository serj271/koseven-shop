<?php defined('SYSPATH') or die('No direct script access.');
/**
 * Reads available controllers using Reflection and creates the menu with submenus
 * 
 * @author	Kemal Delalic	<kemal.delalic@gmail.com>
 * @todo	Simplify this whole class
 */
class View_Admin_Layout_ControllerNav extends Kostache {
	
	/**
	 * Suffix to append to folder array keys
	 */
	const SUCCEED = '_';
	
	/**
	 * @var	string	requested folder (e.g. controller/admin/test)
	 */
	protected $_folder;
	
	protected $_template = 'bootstrap/nav';
	
	/**
	 * @var	array	Links generated by self::load_folder()
	 */
	public $links;

	/*
	 * Reads the specified folder of controllers and creates a menu out of them
	 * 
	 * @param	string	folder to extract controller links from
	 * @return	[View_Admin_Layout_ControllerMenu]
	 */ 
	public function load_folder($folder)
	{
		// Store requested folder
		$this->_folder = $folder;
		
		// Prepend "classes/", because it is the only place we're looking in
		$folder = 'classes/'.$folder;
		
		// List all files inside of the folder
		$files = Kohana::list_files($folder);
		
		if ($cache = Kohana::cache($this->_cache_key($files)))
			return $this->links = $cache;
		
		$clean = $this->_clean_paths($files);
		
		$this->links = $this->_create_menu($clean);
		
		Kohana::cache($this->_cache_key($files), $this->links);
		
		return $this->links;
	}
	
	/**
	 * Checks if the reflected controller has what it takes to get into the menu
	 * 
	 * @param	ReflectionClass	$controller to check
	 * @return	boolean FALSE if fails, controllers' model otherwise
	 */
	public function check(ReflectionClass $controller)
	{
		// By default, only let controllers with a model defined into the menu
		if ($model = Arr::get($controller->getDefaultProperties(), '_model'))
			return $model;
		
		return FALSE;
	}
	
	/**
	 * Returns a cache key for a list of files
	 * 
	 * @param	array	$files
	 * @return	string	
	 */
	protected function _cache_key(array $files)
	{
		/**
		 * Flatten all the files to same level because the cache key is 
		 * generated based on imploded list of files.
		 *
		 * This way adding new files will invalidate the old cache, although it
		 * won't be removed from the FS (use Cache module if you need this)
		 */
		$flat = Arr::flatten($files);
		 
		$keys = array_keys($flat);
		
		return sha1(implode('~', $keys));
	}
	
	/**
	 * Checks controllers in the array using callback function
	 * If $callback isn't specified, self::_check() will be used
	 *
	 * @param	array		$array to check
	 * @param	callback	$callback to use for checking
	 * @return	array
	 * @todo	Rewrite this to use View_Bootstrap_Nav methods for links
	 */
	private function _create_menu(array $array, $callback = NULL)
	{
		// If callback hasn't been specified, use the default
		$callback = is_callable($callback) ? $callback : array($this,'check');
		
		// Simplify the array first and put the children in the right place
		foreach ($array as $key => & $class)
		{
			if (is_array($class))
			{
				// Get all subarray elements to the same level
				$class = $this->_flatten($class, $key);
				
				// Trim the succeeding chunk off the key to check if there
				// is a single element on lower level
				$key = trim($key, self::SUCCEED);
				
				if (isset($array[$key]))
				{
					Arr::unshift($class, $key, $array[$key]);
					
					unset($array[$key]);
				}
			}
		}
		
		$links = array();
		
		foreach ($array as $key => $class)
		{
			if (is_array($class))
			{
				$humanized 	= Inflector::humanize($key);
				
				$links[] = array(
					'submenu' 	=> TRUE,
					'links'		=> $this->_create_menu($class, $callback),
					'title'		=> ucfirst($humanized),
				);
			}
			else
			{
				$prepend 	= str_replace(array('\\','/'), '_', $this->_folder);
				$suffix 	= str_replace(self::SUCCEED, '_', $key);
				$class 		= $prepend.'_'.$suffix;
				
				$controller = new ReflectionClass($class);
				
				if ($model = call_user_func($callback, $controller))
				{
					$humanized = Inflector::humanize($model);
					
					$links[] = array(
						'submenu' 	=> FALSE,
						'text' 		=> ucfirst(Inflector::plural($humanized)),
						'url' 		=> Route::url('admin', array(
							'controller' => $key,
						)),
					);
				}
			}
		}
		
		return $links;
	}

	/**
	 * Recursively cleans `Kohana::list_files()` result from $folder,
	 * so the result looks something like:
	 * 
	 * 	array(
	 * 		'contact' 	=> Contact,
	 * 		'contact ' 	=> array(
	 * 			'message' 	=> Contact_Message,
	 * 			'log ' 		=> array(
	 * 				'info' 	=> Contact_Log_Info,
	 * 				'state'	=> Contact_Log_State,
	 * 			),
	 * 		),
	 * 		'member' 	=> Member,
	 * 	);
	 * 
	 * All keys with array value are appended with self::SUCCEED string
	 * 
	 * @param	array	$files (Kohana::list_files() result)
	 * @return	array
	 */
	private function _clean_paths(array $files)
	{
		$clean = array();
		
		foreach ($files as $path => $child)
		{
			// New path is the basename itself
			$new_path = basename($path);
			
			if (is_array($child))
			{
				// Add SUCCEED string to the key so single rows aren't overwritten
				$clean[$new_path.self::SUCCEED] = $this->_clean_paths($child);
			}
			else
			{
				// Use the filename (without extension) as the key
				$new_path = pathinfo($path, PATHINFO_FILENAME);
				
				$clean[$new_path] = $child;
			}
		}
		
		return $clean;
	}
	
	/**
	 * Flatten method specific for self::_clean_paths() resultset
	 * 
	 * @param	array	$array to flatten
	 * @param	string	$parent key to prepend to each of the child keys
	 * @return	array
	 */
	private function _flatten(array $array, $parent = FALSE)
	{
		$flat = array();
		
		foreach ($array as $key => $value)
		{
			// Prepend the parent key if specified
			$key = $parent ? $parent.$key : $key;
			
			if (is_array($value))
			{
				$flat += $this->_flatten($value, $key);
			}
			else
			{
				$flat[$key] = $value;
			}
		}
		
		// Sort keys before return
		ksort($flat);
		
		return $flat;
	}
	
}
